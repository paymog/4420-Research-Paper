% When making labels follow the Labels and Cross-referencing guide
%
% http://en.wikibooks.org/wiki/LaTeX/Labels_and_Cross-referencing#Introduction
\bibliography{../References/refer}

\section{Abstract}
    The quicksort is a thoroughly studied sorting algorithm and is commonly among the first efficient sorts learned by students of computer science. Many variants of the quicksort have been proposed, from the classic quicksort introduced by Tony Hoare in 1961 \cite{Hoare01011962} to Yaroslavskiy’s dual pivot quicksort introduced in 2009 and used by the Java 7 Standard Library \cite{kushagra2013multi}. Since Hoare’s first proposal, much research has gone into attempting to minimize the total number of swaps done by the sort, the total number of comparisons done by the sort and minimizing the worst case runtime. We aim to experimentally validate the swap and comparison count of several variants of the quicksort and compare the runtimes and various optimizations. Our results SUMMARIZE THE RESULTS

\section{Introduction}
    Sorting is a fundamental concept of computer science wherein a totally ordered multiset is modified such that the elements of the multiset are rearranged (permuted) in either non-decreasing or non-increasing order. A broad range of applications benefit from sorting such as organizing an MP3 library by song title to quickly identifying duplicates in a list to more advanced applications such as load balancing, data compression and computer graphics \cite{sortingSlides}. It is well known that all comparison based sorting algorithms are lower bound by $\Omega(n log n)$ comparisons \cite{Cormen:2001:IA:580470} and quicksort is no exception to this rule. Interestingly, there are non-comparison based sorts such as the counting sort and the radix sort which take advantage of certain properties of the data set and get around the lower bound of comparison base sorts. A summary of space and time complexities can be found in Table \ref{tab:spaceAndTime}.
    
    \begin{table}
        \begin{center}
            \begin{tabular}{|l|l|l|l|}
                    \hline
                    Sort Method &   Space       &   Average Case Time   &   Worst Case Time     \\ \hline \hline
                    Selection   &   $O(1)$      &   $O(n^2)$            &   $O(n^2)$            \\ \hline
                    Insertion   &   $O(1)$      &   $O(n^2)$            &   $O(n^2)$            \\ \hline
                    Merge       &   $O(n)$      &   $O(n\log(n))$       &   $O(n\log(n))$       \\ \hline
                    Quicksort   &   $O(1)$      &   $O(n\log(n))$       &   $O(n^2)$            \\ \hline
                    Radix       &   $O(n)$      &   $O(n*k)$            &   $O(n*k)$            \\ \hline
                    Counting    &   $O(m)$      &   $O(n+m)$            &   $O(n+m)$            \\ \hline
                \end{tabular}
                \caption{Summary of space and time complexities of various sorts where $n$ represents the number of elements, $k$ represents the number of digits in the largest value and $m$ represents the maximum value to be sorted. }
                \label{tab:spaceAndTime}
        \end{center}
    \end{table}

    The quicksort was first introduced by Tony Hoare in \cite{Hoare01011962} and was quickly adopted by the field as a standard sorting algorithm alongside the mergesort \cite{Knuth:1998:ACP:280635} and several other sorting algorithms. Quicksorts simplicity, high average case performance and poor worst case performance has made it one of the most highly studied ``efficient'' sorting algorithms. van Emden \cite{van1970increasing} proposed an optimization to the quicksort in 1970 which resulted in a 15\% improvement on the efficiency of the quicksort. In 1971 Hoare and Foley \cite{foley1971proof} provided a formal proof of other correctness of the quicksort. In 1977, Sedgewick did a thorough analysis of quicksort \cite{sedgewick1977analysis} and then in 1978 Sedgewick again published a paper on the quicksort exploring various implementations and proposing several optimizations \cite{sedgewick1978implementing}. The academic interest in the quicksort has not slowed since the late 1970s; papers regarding the quicksort continue to be published for adapting the quicksort to GPUs \cite{cederman2009gpu}, providing optimal pivot selection \cite{martinez2001optimal} and using more than one pivot \cite{edmondson2005m}. 

    In this paper we explore, compare and contrast the classic implementation of the quicksort against various multipivot quicksort implementations and their respective optimizations. We are particularly interested in comparing the classic quicksort against the standard dual pivot quicksort, Yaroslavskiy's dual pivot quicksort\cite{yaroslavskiy2009dual}, Aum\"{u}ller and Dietzfelbinger's optimized dual-pivot quicksort \cite{Aumuller:2013:OPD:2525857.2525862}, Edmonson's M-Pivot quicksort \cite{edmondson2005m} and the three pivot quicksort introduced by Kushagra et al \cite{kushagra2013multi}. We will first introduce the various quicksorts by providing a brief overview of their behaviour, implementation and potential optimizations. Next we will discuss the experiments and provide their results. Following this we provide an analysis, discuss future work and conclude the paper. 

\section{Quicksort}
		
	\subsection{Classic Quicksort}
		\label{subsec:ClassicQSortIntro}
	
	\subsection{Dual Pivot Quicksort}
		\label{subsec:DualPivotQSortIntro}
	
	\subsection{Optimal Dual Pivot Quicksort}	
		\label{subsec:OptimalDualPivotQSortIntro}
	
	\subsection{Three Pivot Quicksort}	
		\label{subsec:ThreePivotQSortIntro}
	
	\subsection{Yaroslavskiy Quicksort}	
		\label{subsec:YaroslavskiyQSortIntro}
	
	\subsection{M Pivot Quicksort}	
		\label{subsec:MPivotQSortIntro}
	
		%
		% The following can be deleted
		% This is just here to see what the compiled document looks like
		RAWR
		\subsubsection{Testing}
			Just to test the subsection code.
			Test text : Recall from section \ref{subsec:ClassicQSortIntro} on page \pageref{subsec:ClassicQSortIntro}

	\subsection{Summary}
		%***************************************************************************************************
		% Tables will automatically move around when more text is added.
		% LaTeX is trying to place the tables [an soon enough figures too when I add them]
		% into "nice" places so that text is the least "messed" up.
		% So don't worry that the tables are all over the place [which includes before the introduction]
		% Even though the code for the tables are clearly after it.
		%***************************************************************************************************
		\begin{table}
			\begin{center}
				\begin{tabular}{|r|l|}
					\hline
					Sort Method        &   Comparisons                          \\ \hline \hline
					Classic            &   $2n \log n - 1.51n  + O(\log(n))$    \\ \hline
					Dual Pivot         &   $2.13n \log n - 2.57n + O(\log(n))$  \\ \hline
					Optimal Dual Pivot &   $1.8n \log n + O(n)$                 \\ \hline
					Three Pivot        &   $1.846n \log n + O(n)$               \\ \hline
					Yaroslavskiy       &   $1.9n \log n - 2.46n + O(\log(n))$   \\ \hline
					M Pivot            &   $O(n \log n)$                        \\ \hline
				\end{tabular}
				\caption{Summary table of theoretical comparisons.}
				\label{tab:CompSummary}
			\end{center}
		\end{table}

		\begin{table}
			\begin{center}
				\begin{tabular}{|r|l|}
					\hline
					Sort Method         &     Swaps \\ \hline \hline
					Classic             &  $0.33n \log n - 0.58n + O(\log(n))$ \\ \hline
					Dual Pivot          &  $0.8n \log n -0.3n + O(\log(n))$    \\ \hline
					Optimal Dual Pivot  &  $0.33n \log n + O(n)$               \\ \hline
					Three Pivot         &  $0.615n \log n + O(n)$              \\ \hline
					Yaroslavskiy        &  $0.6n \log n + 0.08n + O(\log(n))$  \\ \hline
					M Pivot             &  $O(n \log n)$                       \\ \hline
				\end{tabular}
				\caption{Summary table of theoretical swaps.}
				\label{tab:SwapSummary}
			\end{center}
		\end{table}